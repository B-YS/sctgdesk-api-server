/* tslint:disable */
/* eslint-disable */
/**
 * sctgdesk-api-server
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { CurrentUserRequest } from '../models';
import { LoginReply } from '../models';
import { LoginRequest } from '../models';
import { LogoutReply } from '../models';
import { OidcAuthRequest } from '../models';
import { OidcAuthUrl } from '../models';
import { OidcResponse } from '../models';
/**
 * LoginApi - axios parameter creator
 * @export
 */
export const LoginApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Login
         * @param {LoginRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (body: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling login.');
            }
            const localVarPath = `/api/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Login options  This is called by the client for knowing the Oauth2 provider(s) available You must provide a list of Oauth2 providers in the `oauth2.toml` config file The config file can be overridden by the `OAUTH2_CONFIG_FILE` environment variable  # Limitations  Currently it uses the client id as the user id the limitation is that the client cannot retrieve its address book if the client uses a different client. For having a `real` user name. We need to add a step after the Oauth2 authorization code is exchanged for an access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/login-options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Log the user out
         * @param {CurrentUserRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (body: CurrentUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling logout.');
            }
            const localVarPath = `/api/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authorization required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * OIDC Auth request  This entrypoint is called by the client for getting the authorization url for the Oauth2 provider he chooses  For testing you can generate a valid uuid field with the following command: `uuidgen | base64`
         * @param {OidcAuthRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oidcAuth: async (body: OidcAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling oidcAuth.');
            }
            const localVarPath = `/api/oidc/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * OIDC Auth callback  This entrypoint is the OAuth2 callback. It exchanges the code for an access token and stores it in the state
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oidcCallback: async (code: string, state: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling oidcCallback.');
            }
            // verify required parameter 'state' is not null or undefined
            if (state === null || state === undefined) {
                throw new RequiredError('state','Required parameter state was null or undefined when calling oidcCallback.');
            }
            const localVarPath = `/api/oidc/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * OIDC State request  This entrypoint is called by the client for getting the status of the OIDC session it returns an empty json object if the session is not found it returns an access token if the session is found
         * @param {string} code 
         * @param {string} id 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oidcState: async (code: string, id: string, uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling oidcState.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling oidcState.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling oidcState.');
            }
            const localVarPath = `/api/oidc/auth-query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginApi - functional programming interface
 * @export
 */
export const LoginApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Login
         * @param {LoginRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(body: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<LoginReply>>> {
            const localVarAxiosArgs = await LoginApiAxiosParamCreator(configuration).login(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Login options  This is called by the client for knowing the Oauth2 provider(s) available You must provide a list of Oauth2 providers in the `oauth2.toml` config file The config file can be overridden by the `OAUTH2_CONFIG_FILE` environment variable  # Limitations  Currently it uses the client id as the user id the limitation is that the client cannot retrieve its address book if the client uses a different client. For having a `real` user name. We need to add a step after the Oauth2 authorization code is exchanged for an access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<string>>>> {
            const localVarAxiosArgs = await LoginApiAxiosParamCreator(configuration).loginOptions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Log the user out
         * @param {CurrentUserRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(body: CurrentUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<LogoutReply>>> {
            const localVarAxiosArgs = await LoginApiAxiosParamCreator(configuration).logout(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * OIDC Auth request  This entrypoint is called by the client for getting the authorization url for the Oauth2 provider he chooses  For testing you can generate a valid uuid field with the following command: `uuidgen | base64`
         * @param {OidcAuthRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oidcAuth(body: OidcAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<OidcAuthUrl>>> {
            const localVarAxiosArgs = await LoginApiAxiosParamCreator(configuration).oidcAuth(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * OIDC Auth callback  This entrypoint is the OAuth2 callback. It exchanges the code for an access token and stores it in the state
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oidcCallback(code: string, state: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<string>>> {
            const localVarAxiosArgs = await LoginApiAxiosParamCreator(configuration).oidcCallback(code, state, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * OIDC State request  This entrypoint is called by the client for getting the status of the OIDC session it returns an empty json object if the session is not found it returns an access token if the session is found
         * @param {string} code 
         * @param {string} id 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oidcState(code: string, id: string, uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<OidcResponse>>> {
            const localVarAxiosArgs = await LoginApiAxiosParamCreator(configuration).oidcState(code, id, uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LoginApi - factory interface
 * @export
 */
export const LoginApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Login
         * @param {LoginRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(body: LoginRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<LoginReply>> {
            return LoginApiFp(configuration).login(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Login options  This is called by the client for knowing the Oauth2 provider(s) available You must provide a list of Oauth2 providers in the `oauth2.toml` config file The config file can be overridden by the `OAUTH2_CONFIG_FILE` environment variable  # Limitations  Currently it uses the client id as the user id the limitation is that the client cannot retrieve its address book if the client uses a different client. For having a `real` user name. We need to add a step after the Oauth2 authorization code is exchanged for an access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginOptions(options?: AxiosRequestConfig): Promise<AxiosResponse<Array<string>>> {
            return LoginApiFp(configuration).loginOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * Log the user out
         * @param {CurrentUserRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(body: CurrentUserRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<LogoutReply>> {
            return LoginApiFp(configuration).logout(body, options).then((request) => request(axios, basePath));
        },
        /**
         * OIDC Auth request  This entrypoint is called by the client for getting the authorization url for the Oauth2 provider he chooses  For testing you can generate a valid uuid field with the following command: `uuidgen | base64`
         * @param {OidcAuthRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oidcAuth(body: OidcAuthRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<OidcAuthUrl>> {
            return LoginApiFp(configuration).oidcAuth(body, options).then((request) => request(axios, basePath));
        },
        /**
         * OIDC Auth callback  This entrypoint is the OAuth2 callback. It exchanges the code for an access token and stores it in the state
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oidcCallback(code: string, state: string, options?: AxiosRequestConfig): Promise<AxiosResponse<string>> {
            return LoginApiFp(configuration).oidcCallback(code, state, options).then((request) => request(axios, basePath));
        },
        /**
         * OIDC State request  This entrypoint is called by the client for getting the status of the OIDC session it returns an empty json object if the session is not found it returns an access token if the session is found
         * @param {string} code 
         * @param {string} id 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oidcState(code: string, id: string, uuid: string, options?: AxiosRequestConfig): Promise<AxiosResponse<OidcResponse>> {
            return LoginApiFp(configuration).oidcState(code, id, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoginApi - object-oriented interface
 * @export
 * @class LoginApi
 * @extends {BaseAPI}
 */
export class LoginApi extends BaseAPI {
    /**
     * Login
     * @param {LoginRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public async login(body: LoginRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<LoginReply>> {
        return LoginApiFp(this.configuration).login(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Login options  This is called by the client for knowing the Oauth2 provider(s) available You must provide a list of Oauth2 providers in the `oauth2.toml` config file The config file can be overridden by the `OAUTH2_CONFIG_FILE` environment variable  # Limitations  Currently it uses the client id as the user id the limitation is that the client cannot retrieve its address book if the client uses a different client. For having a `real` user name. We need to add a step after the Oauth2 authorization code is exchanged for an access token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public async loginOptions(options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<string>>> {
        return LoginApiFp(this.configuration).loginOptions(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Log the user out
     * @param {CurrentUserRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public async logout(body: CurrentUserRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<LogoutReply>> {
        return LoginApiFp(this.configuration).logout(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * OIDC Auth request  This entrypoint is called by the client for getting the authorization url for the Oauth2 provider he chooses  For testing you can generate a valid uuid field with the following command: `uuidgen | base64`
     * @param {OidcAuthRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public async oidcAuth(body: OidcAuthRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<OidcAuthUrl>> {
        return LoginApiFp(this.configuration).oidcAuth(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * OIDC Auth callback  This entrypoint is the OAuth2 callback. It exchanges the code for an access token and stores it in the state
     * @param {string} code 
     * @param {string} state 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public async oidcCallback(code: string, state: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<string>> {
        return LoginApiFp(this.configuration).oidcCallback(code, state, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * OIDC State request  This entrypoint is called by the client for getting the status of the OIDC session it returns an empty json object if the session is not found it returns an access token if the session is found
     * @param {string} code 
     * @param {string} id 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public async oidcState(code: string, id: string, uuid: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<OidcResponse>> {
        return LoginApiFp(this.configuration).oidcState(code, id, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}
